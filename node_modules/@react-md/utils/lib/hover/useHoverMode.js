"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.useHoverMode = void 0;
var react_1 = require("react");
var mode_1 = require("../mode");
var useOnUnmount_1 = require("../useOnUnmount");
var constants_1 = require("./constants");
var useHoverModeContext_1 = require("./useHoverModeContext");
function useHoverMode(_a) {
    var _b = _a === void 0 ? {} : _a, _c = _b.disabled, disabled = _c === void 0 ? false : _c, _d = _b.sticky, sticky = _d === void 0 ? false : _d, propOnClick = _b.onClick, propOnMouseEnter = _b.onMouseEnter, propOnMouseLeave = _b.onMouseLeave, _e = _b.defaultVisible, defaultVisible = _e === void 0 ? false : _e, _f = _b.exitVisibilityDelay, exitVisibilityDelay = _f === void 0 ? sticky ? constants_1.DEFAULT_HOVER_MODE_STICKY_EXIT_TIME : 0 : _f;
    var mode = (0, mode_1.useUserInteractionMode)();
    var isTouch = mode === "touch";
    var _g = (0, react_1.useState)(defaultVisible), visible = _g[0], setVisible = _g[1];
    var _h = (0, react_1.useState)(false), stuck = _h[0], setStuck = _h[1];
    var timeoutRef = (0, react_1.useRef)();
    var skipReset = (0, react_1.useRef)(defaultVisible);
    var _j = (0, useHoverModeContext_1.useHoverModeContext)(), visibleInTime = _j.visibleInTime, enableHoverMode = _j.enableHoverMode, disableHoverMode = _j.disableHoverMode, startDisableTimer = _j.startDisableTimer;
    var active = visibleInTime === 0;
    (0, react_1.useEffect)(function () {
        if (sticky && !visible) {
            setStuck(false);
        }
    }, [visible, sticky]);
    (0, useOnUnmount_1.useOnUnmount)(function () {
        window.clearTimeout(timeoutRef.current);
    });
    (0, react_1.useEffect)(function () {
        if (disabled) {
            return;
        }
        var reset = function () {
            setVisible(false);
            disableHoverMode();
            window.clearTimeout(timeoutRef.current);
        };
        // this is just used so the `defaultOption` can be used
        if (!skipReset.current) {
            reset();
        }
        skipReset.current = false;
        window.addEventListener("mousedown", reset);
        return function () {
            window.removeEventListener("mousedown", reset);
        };
    }, [disableHoverMode, mode, disabled]);
    var onMouseEnter = (0, react_1.useCallback)(function (event) {
        propOnMouseEnter === null || propOnMouseEnter === void 0 ? void 0 : propOnMouseEnter(event);
        if (stuck || disabled || isTouch || event.isPropagationStopped()) {
            return;
        }
        window.clearTimeout(timeoutRef.current);
        if (visibleInTime === 0) {
            enableHoverMode();
            setVisible(true);
            return;
        }
        timeoutRef.current = window.setTimeout(function () {
            enableHoverMode();
            setVisible(true);
        }, visibleInTime);
    }, [disabled, enableHoverMode, isTouch, propOnMouseEnter, stuck, visibleInTime]);
    var onMouseLeave = (0, react_1.useCallback)(function (event) {
        propOnMouseLeave === null || propOnMouseLeave === void 0 ? void 0 : propOnMouseLeave(event);
        if (stuck || disabled || isTouch || event.isPropagationStopped()) {
            return;
        }
        startDisableTimer();
        window.clearTimeout(timeoutRef.current);
        if (exitVisibilityDelay === 0) {
            setVisible(false);
            return;
        }
        timeoutRef.current = window.setTimeout(function () {
            setVisible(false);
        }, exitVisibilityDelay);
    }, [
        disabled,
        exitVisibilityDelay,
        isTouch,
        propOnMouseLeave,
        startDisableTimer,
        stuck,
    ]);
    var onClick = (0, react_1.useCallback)(function (event) {
        propOnClick === null || propOnClick === void 0 ? void 0 : propOnClick(event);
        if (event.isPropagationStopped() || disabled) {
            return;
        }
        startDisableTimer();
        window.clearTimeout(timeoutRef.current);
    }, [disabled, propOnClick, startDisableTimer]);
    var onStickyClick = (0, react_1.useCallback)(function (event) {
        propOnClick === null || propOnClick === void 0 ? void 0 : propOnClick(event);
        if (event.isPropagationStopped() || disabled) {
            return;
        }
        if (!stuck) {
            setStuck(true);
            setVisible(true);
            disableHoverMode();
        }
        else {
            setStuck(false);
            setVisible(function (prevVisible) { return !prevVisible; });
        }
    }, [disableHoverMode, disabled, propOnClick, stuck]);
    var handlers = {
        onClick: onClick,
        onMouseEnter: onMouseEnter,
        onMouseLeave: onMouseLeave,
    };
    var stickyHandlers;
    if (sticky) {
        stickyHandlers = __assign(__assign({}, handlers), { onClick: onStickyClick });
    }
    return {
        active: active,
        stuck: sticky ? stuck : undefined,
        visible: visible,
        setVisible: setVisible,
        handlers: handlers,
        stickyHandlers: stickyHandlers,
        enableHoverMode: enableHoverMode,
        disableHoverMode: disableHoverMode,
        startDisableTimer: startDisableTimer,
    };
}
exports.useHoverMode = useHoverMode;
//# sourceMappingURL=useHoverMode.js.map