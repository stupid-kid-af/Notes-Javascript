"use strict";
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.useLayoutNavigation = void 0;
var react_1 = require("react");
var link_1 = require("@react-md/link");
var tree_1 = require("@react-md/tree");
/**
 * @internal
 */
var getParentIds = function (itemId, navItems) {
    return (0, tree_1.getItemsFrom)(navItems, itemId).map(function (_a) {
        var itemId = _a.itemId;
        return itemId;
    });
};
/**
 * This is used to disable the item select and multi item select functionality
 * since only one id can be selected at a time, and it'll always be the current
 * pathname's itemId
 *
 * @internal
 */
var noop = function () {
    // do nothing
};
/**
 * This used to just be `pathname.replace(/\?.*$/, "")` but that can apparently
 * cause performance issues or a DoS attack if the pathname contains multiple
 * ?`?` (shouldn't really be possible though)
 *
 * @remarks \@since 2.9.0
 */
var removeQueryParams = function (pathname) {
    var i = pathname.indexOf("?");
    if (i === -1) {
        return pathname;
    }
    return pathname.substring(0, i);
};
/**
 * This is a pretty reasonable default implementation for having a navigation
 * tree within the Layout component. The way it'll work is that the current
 * route will be the only selected item within the tree. When the pathname
 * changes, the selectedIds will be updated to only be the current pathname once
 * again.
 *
 * This means that you can use whatever routing library or history provider that
 * ensures that your layout re-renders on a path change.
 *
 * @see LayoutNavigationTree for description of the navItems
 * @param navItems - All the navigation items within your layout. This is used
 * for determining which parent tree items should be expanded when the route
 * changes so the current route won't be hidden from view. This sort of flow
 * happens if you have a link outside of the navigation tree.
 * @param pathname - The current pathname
 * @param linkComponent - The link component to use within the navigation tree
 * for any item that has a `to` or `href` attribute. This defaults to the `Link`
 * from `@react-md/link` but should be changed to whatever link component you
 * need if using a routing library like `react-router`.
 * @returns the required `Tree` selection and expansion state and handlers that
 * should be passed to the `Layout` component.
 */
function useLayoutNavigation(navItems, pathname, linkComponent) {
    if (linkComponent === void 0) { linkComponent = link_1.Link; }
    var itemId = removeQueryParams(pathname);
    var _a = (0, tree_1.useTreeItemExpansion)(function () { return getParentIds(itemId, navItems); }), expandedIds = _a.expandedIds, onItemExpansion = _a.onItemExpansion, onMultiItemExpansion = _a.onMultiItemExpansion;
    var prevItemId = (0, react_1.useRef)(itemId);
    var prevNavItems = (0, react_1.useRef)(navItems);
    if (prevItemId.current !== itemId || prevNavItems.current !== navItems) {
        prevItemId.current = itemId;
        prevNavItems.current = navItems;
        onMultiItemExpansion(Array.from(new Set(__spreadArray(__spreadArray([], expandedIds, true), getParentIds(itemId, navItems), true))));
    }
    return {
        navItems: navItems,
        multiSelect: false,
        selectedIds: [itemId],
        onItemSelect: noop,
        onMultiItemSelect: noop,
        expandedIds: expandedIds,
        onItemExpansion: onItemExpansion,
        onMultiItemExpansion: onMultiItemExpansion,
        linkComponent: linkComponent,
    };
}
exports.useLayoutNavigation = useLayoutNavigation;
//# sourceMappingURL=useLayoutNavigation.js.map